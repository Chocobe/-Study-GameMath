# 02-함수

# 1. 함수(function) 의 기초

게임은 `공간과 공간의 변환` 으로 구성되어 있습니다.

유저의 모든 액션은 화면에 변환을 일으키게 되기 때문입니다.

이러한 `변환` 은 `집합과 집합의 대응 관계` 에 기반하는데, 이러한 메커니즘을 설명하는 것이 바로 `함수(Function)` 입니다.


<br /><br />


두 집합의 대응 관계란 다음과 같이 표현할 수 있습니다.

* 집합 `X` 의 요소 `x`

* 집합 `Y` 의 요소 `y`

* `X` 집합과 `Y` 집합의 대응관계를 표현하면 다음과 같습니다.
  * `y = f(x)`


<br /><br />


`함수(Function)` 은 성립 조건이 있습니다.

1. 첫번째 집합의 `모든 요소` 가 사용되어야 합니다.
   * 첫번째 집합에서 사용되지 않는 요소가 1개라도 있으면 성립하지 않습니다.

2. 첫번째 집합의 요소가 두번째 집합의 요소에 `오직 1개에만 대응` 하여야 합니다.
   * 첫번째 집합의 요소가 두번째 집합의 요소에 `2개 이상 대응` 된다면 성립하지 않습니다.


<br /><br />


함수를 구성하는 집합에는 명칭이 있습니다.

* `정의역 (Domain)`
  * 집합 `X` 의 명칭 입니다.
  * 모든 요소가 집합 `Y` 에 대응 되어야 합니다.

* `공역 (Codomain)`
  * 집합 `Y` 의 명칭 입니다.
  * 집합 `X` 와 대응되지 않는 요소가 있을 수 있습니다.

* `치역 (Range)`
  * 집합 `X` 와 대응하는 집합 `Y` 의 요소로 구성된 집합을 지칭 합니다.
  * 집합 `Y` 의 `부분 집합` 이 됩니다.

<br />

`함수(Function)` 의 구성 집합을 `프로그램` 관점에서 보면 다음과 같습니다.

* `정의역 (Domain)` === `입력값 (input)`
* `공역 (Codomain)` === `출력값 (output)`


<br /><br />


함수는 대응 관계에 따라서 4가지로 분류할 수 있습니다.

* `전사 함수 (Surjection Function)`
  * 조건은 다음과 같습니다.
    * `공역(Codomain)` === `치역(Range)`
    * `정의역(Domain)` 과 대응되는 `공역(Codomain)` 요소중에 `중복 대응` 된 요소가 있는 경우

* `단사 함수 (Injection Function)`
  * 조건은 다음과 같습니다.
    * `공역(Codomain)` > `치역(Range)`
    * `정의역(Domain)` 과 `공역(Codomain)` 이 `중복 대응 없는` 경우

* `전단사 함수 (Bijection Function)`
  * `전사` 와 `단사` 모두 충족하는 경우

* `일반 함수 (General Function)`
  * `전사` 도 아니고 `단사` 도 아닌 경우
    * 중복 대응되는 `치역 (Range)` 도 있고, `공역(Codomain)` 과 `치역(Range)` 가 다른 경우



<br /><hr /><br />



# 2. 곱집합(Cartesian Product)

두개의 집합의 모든 `순서쌍` 으로 만든 `집합` 을 `곱집합(Cartesian Product)` 라고 합니다.

각 `순서쌍` 은 `(a, b)` 로 표기할 수 있으며, 이러한 표기법을 `튜플(Tuple)` 이라고 합니다.

* `집합 A` 의 원소: a, b
* `집합 B` 의 원소: 1, 2
* `집합 A` 와 `집합 B` 의 `곱집합`: (a, 1), (a, 2), (b, 1), (b, 2)

<br />

이렇게 만들어진 `곱집합(Cartesian Product)` 은 기호로 `A × B` 라고 표기 합니다.

<br />

`이항 연산` 을 함수로 해석하면 다음과 같습니다.

* `정의역 X × Y` (`집합 X` 와 `집합 Y` 의 `곱집합` 이 `정의역` 이 됩니다.)
  * `집합 X 의 원소 x`
  * `집합 Y 의 원소 y`

* `공역 Z` 의 원소 `z`

* `z = f(x, y)`



<br /><hr /><br />



# 3. 합성함수(Composition)

`3개의 집합` 과 `2개의 함수` 가 있을 때, `3개의 집합` 이 반드시 대응되는 함수를 `합성함수(Composition)` 이라고 합니다.

* 집합
  * `X`
  * `Y`
  * `Z`

* 함수
  * `y = f(x)`
  * `z = g(y)`

* `합성함수(Composition)`
  * `(g 。f)(x)`
    * 먼저 실행하는 함수 `f` 를 `우측` 에 표기 합니다.
    * `(g 。f)(x)` === `g(f(x))`


<br /><br />


함수에는 `대응 관계` 가 있습니다.

* `항등함수 (Identity Function)`
* `역함수 (Inverse Function)`


<br /><br />


이전에 살펴보았던 `전단사 함수(Bijection Function)` 를 `항등 함수(Identity Function)` 이라고 합니다.

`항등함수 (Identity Function)` 은 이전에 살펴보았던 `전단사 함수 (Bijection Function)` 이며, 기호로 표현하면, `i` 입니다.


<br /><br />


`역함수 (Inverse Function)` 은 두 집합의 대응관계를 `거꾸로` 하여도 `함수 조건이 성립` 되는 함수 입니다.

`역함수 (Inverse Function)` 가 존재하기 위해서는 반드시 `전단사 함수 (Bijection Function)` 이어야 합니다.

이유는 `전단사 함수 (Bijection Function)` 이 아닌 경우, 두 집합의 관계를 거꾸로 하게 되면, 함수의 조건이 성립하지 않기 때문 입니다.

<br />

`전단사 함수 (Bijection Function)` 을 `y = f(x)` 라고 한다면, `역함수 (Inverse Function)` 은 `x = f⁻¹(y)` 로 표현 합니다.


<br /><br />


`역함수 (Inverse Function)` 이 존재하는 함수 `f` 와 `f⁻¹` 의 `합성함수 (Composition)` 은 `항등함수 (Identity Function)` 이 됩니다.

* `f⁻¹ 。f` === `i`


<br /><br />


그리고 `전단사 함수 (Bijection Function)` 인 `합성함수 (Composition)` 의 `역함수 (Inversion Function)` 은 다음과 같이 표기할 수 있습니다.

* `(g 。f)⁻¹` === `f⁻¹ 。g⁻¹`
* `g` 함수의 `역함수` 를 먼저 실행한 후, `f` 함수의 `역함수` 를 실행하면, `합성함수 (g 。f)` 의 `역함수 (g 。f)⁻¹` 가 됩니다.



<br /><hr /><br />



게임은 `공간과 공간의 변환` 이라고 하였습니다.

이러한 `변환` 은 `행렬의 곱` 연산을 사용하게 되는데, 이 `행렬의 곱` 연산이 바로 `합성함수` 에 대응 됩니다.
