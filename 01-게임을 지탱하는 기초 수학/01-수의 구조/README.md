# 01-수의 시각화
# 1. 수의 시각화

게임은 `벡트` 위에 컨텐츠를 나타내어 만들게 됩니다.

우리가 사용할 `벡터` 는 `실수 (R)` 로 이루어져 있는데, `실수 (R)` 란 다음과 같습니다.

> `실수 집합 R` 은 수와 수 사이에 빈틈이 없는 `무한의 요소` 로 이루어진 수의 집합 입니다.
>
> `벡터` 연산의 이해를 위해, `사칙 연산` 에서 좀 더 확장한 `수의 체계` 를 이해할 필요가 있습니다. (`체(Field) 의 공리(Axiom)`)

<br />

이러한 무한히 연결된 `실수 (R)` 집합을 점으로 표현하면, `무한히 연결된 하나의 직선` 으로 그릴 수 있습니다.

> `벡터` 를 사용할 때는, `원점 (0 지점)` 을 기준으로 `좌, 우` 대칭으로 나열된 수를 떠올리면 이해하기 수월합니다.
> 
> 얻을 수 있는 정보
> 1. `수의 크기` (절대값)
> 2. `수가 속한 세계 (방향)` (양수, 음수)



<br /><hr /><br />



# 2. 이항 연산

수의 시각화를 통해, `벡터` 위에 나타낸 수를 떠올릴 수 있게 되었습니다.

이번에는 `연산 시스템` 에 대한 이해가 필요한데, 

이번에는 이러한 수를 어떻게 연산할 것인가에 대한 `연산 시스템`, 즉 `이항 연산(Binary Operation)` 에 대해 정리합니다.


<br /><br />


`수의 집합` 은 단순한 `숫자의 집합` 뿐만 아니라, 어떻게 연산할 것인가에 대한 `연산 시스템` 까지 포함하고 있습니다.

`벡터` 위의 두 수를 사용하여, 어떻게 연산할 것인가에 대한 `이항 연산(Binary Operation)` 은, `함수` 가 되며, `연산 결과` 를 만드는 방법이 됩니다.

> 두 수의 `이항 연산(Binary Operation)` 결과가 해당 집합에 포함되어 있는 경우, 이를 `닫혀 있다` 라고 표현합니다.



<br /><hr /><br />



## 2-1. 사칙 연산의 재구성

`사칙 연산` 은 `+`, `-`, `*`, `/` 를 말합니다.

일반적으로 사용하던 `사칙 연산` 을 바라보는 관점에서 `-` 와 `/` 를 다음과 같은 관점으로 생각해 봅니다.

* 20 `-` 10 === 20 `+` (-10)
* 20 `/` 10 === 20 `*` (1/10)



<br /><hr /><br />



## 2-2. 곱셈의 표기

일반적으로 곱셈은 `×` 기호로 표기를 하지만, 수학에서는 `· (Center Dot)` 으로 표기합니다.



<br /><hr /><br />



## 2-3. 덧셈 연산의 시각화

`1 - 5` 수식에 `사칙 연산의 재구성` 을 적용하면 다음과 같이 수식을 바꿀 수 있습니다.

```bash
1 - 5 === 1 + (-5)
```

<br />

`1 + (-5)` 를 해석하면 다음과 같이 할 수 있습니다.

* `1` 이라는 요소를 `좌측` 으로 `5`간 이동 시키기
* 결과 `1` 요소는 `좌측` `4` 의 위치에 있게 됩니다.


즉, `덛셈 연산` 은 `점을 평행 이동` 시키는 연산 입니다.



<br /><hr /><br />



## 2-4. 곱셈 연산의 시각화

즉, `곱셈 연산` 은 `원점을 기준으로 원소의 크기` 에 `배율` 과 `방향 반전` 을 적용시키는 연산 입니다.

* `원소` 에 곱해지는 수가 `음수` 일 경우, `방향 반전` 이 되며, 이는 `회전 개념` 이 됩니다.
  * `양수의 곱`: 원소의 방향 유지
  * `음수의 곱`: 원소의 방향을 `180˚ 회전`
  * 연산을 떠올리는 순서
    1. `원소` 에 `배율` 적용 (`곱셈`)
    2. `방향` 결정



<br /><hr /><br />



# 3. 이항 연산의 성질

`이항 연산의 성질` 은 3가지가 있습니다.

* `교환 법칙 (Commutativity)`
  * 연산의 순서를 바꾸어도 동일한 결과가 나오는 법칙 입니다.
  * `a · b === b · a`

* `결합 법칙 (associativity)`
  * 3개의 원소를 연산할 때, 뒤의 연산을 먼저 하여도 동일한 결과가 나오는 법칙 입니다.
  * `(a · b) · c === a · (b · c)`

* `분배 법칙 (Distributivity)`
  * `좌/우` 분배 법칙 모두 동일한 결과를 얻는 경우를 지칭하는 법칙 입니다.
  * `좌` 분배 법칙: `a + (b · c) === a · b + a · c`
  * `우` 분배 법칙: `(b + c) · a === b · a + c · a`

<br />

이러한 `이항 연산의 성질` 은 만족할 수도 있고, 만족하지 않는 경우도 있습니다.



<br /><hr /><br />



## 3-1. 항등원 (Identity)

`어떤 원소 a` 에 `b` 를 연산한 결과가 `a` 그대로 나올 경우, `b` 를 `항등원 (Identity)` 라고 합니다.

그러므로 `덧셈` 과 `곱셈` 의 `항등원 (Identity)` 는 다음과 같습니다.

* 덧셈의 항등원: `0`
  * `a + 0 === a`

* 곱셈의 항등원: `1`
  * `a · 1 === a`



<br /><hr /><br />


## 3-2. 역원 (Inverse)

`어떤 원소 a` 의 `항등원 (Identity) A` 가 있을 때, `어떤 원소 a` 에 연산한 결과가 `항등원 (Identity) A` 가 되는 원소를 `역원 (Inverse)` 라고 합니다.

`덧셈` 과 `곱셈` 에 대한 `역원 (Inverse)` 는 다음과 같습니다.

* 덛셈의 역원: `-a`
  * `a` 의 항등원 (Identity): `0`
  * `a` 의 역원 (Inverse): `-a`
  * `a + (-a) === 0`
  * 덧셈의 `역원 (Inverse)` 는 원소 `a` 의 반대 부호가 되므로, `반수 (Opposite Number)` 라고 합니다.

* 곱셈의 역원: `1/a`
  * `a` 가 `0` 이 아니어야 합니다.
  * `a` 의 항등원 (Identity): `1`
  * `a` 의 역원 (Inverse): `1/a`
  * `a * (1/a) === 1`
  * 곱셈의 `역원 (Inverse)` 는 원소 `a` 의 `역수 (Reciprocal)` 이라고 합니다.

<br />

`역원 (Inverse)` 를 `사칙연산` 에 적용해 보면 다음과 같습니다.

* `뺄셈` 을 `덧셈` 으로 표현하면, 
  * `원소 a` 와 `원소 b 의 역원` 을 `더하는` 식이 됩니다.
  * `a + (-b)`

* `나눗셈` 을 `곱셈` 으로 표현하면, 
  * `원소 a` 와 `원소 b의 역원` 을 `곱하는` 식이 됩니다.
  * `a * (1/b)`

<br />

이렇게 `뺄셈` 과 `나눗셈` 을 `덧셈` 과 `곱셈` 으로 표현하기 위해, `역원 (Inverse)` 를 사용하는 이유는 다음과 같습니다.

* `뺄셈` 과 `나눗셈` 은 `교환 법칙 (Commutativity)` 이 `성립되지 않기 때문` 입니다.

```javascript
// 뺄셈으로는 교환법칙 (Commutativity) 를 성립하지 않습니다.
const a = 5;
const b = 2;

function sub = (a, b) => a - b;

console.log(sub(a, b));
// 5 - 2
// === 3

console.log(sub(b, a));
// 2 - 5
// === -3
```

<br />

```javascript
// 덧셈은 교환법칙 (Commutativity) 를 성립 합니다.
const a = 5;
const b = -2;

const sum = (a, b) => a + b;

console.log(sum(a, b));
// 5 + (-2)
// === 3

console.log(sum(b, a));
// -2 + 5
// === 3
```

<br />

```javascript
// 나눗셈은 교환법칙 (Commutativity) 를 성립하지 않습니다.
const a = 5;
const b = 2;

const div = (a, b) => a / b;

console.log(div(a, b));
// 5 / 2
// === 2.5

console.log(div(b, a));
// 2 / 5
// 0.4
```

<br />

```javascript
// 곱셈은 교환법칙 (Commutativity) 를 성립 합니다.
const a = 5;
const b = 1/2;

const mul = (a, b) => a * b;

console.log(mul(a, b));
// 5 * (1/2)
// === 2.5

console.log(mul(b, a));
// (1/2) * 5
// === 2.5
```



<br /><hr /><br />



# 4. 체(Field) 의 공리(Axiom)

`덧셈` 과 `곱셈` 을 사용한 `실수의 체계` 와 `연산 구조` 를 살펴보기 위해 `공리 (Axiom)` 에 대해 정리해 보겠습니다.

* `공리 (Axiom)`: 이론 체계에서 증명이 필요없는 `가장 기초적인 명체` 입니다.



<br /><hr /><br />



## 4-1. 군(Group) 의 공리(Axiom)

`군(Group) 의 공리(Axiom)` 는, 아래의 조건을 모두 만족하는 경우를 지칭합니다.

1. `덧셈` 연산에 대해 `닫혀` 있어야 합니다. (=== `closure`)
   * `닫혀있다`: `덧셈` 연산의 결과가 `실수 (R)` 에 속하는 원소임을 말합니다.

2. `덧셈` 연산에 대해 `결합 법칙 (Associativity)` 를 만족해야 합니다.
   * `a + (b + c) === (a + b) + c`

3. `덧셈` 연산의 `항등원 (Identity element)` 가 존재해야 합니다.
   * `a` 의 항등원 (Identity): `0`

4. `덧셈` 연산의 `역원 (Inverse element)` 가 존재해야 합니다.
   * `a` 의 역원 (Inverse): `-a`

<br />

`군(Group) 의 공리` 를 만족하는 경우, `기호` 로 다음과 같이 표현합니다.

* `(R, ＋)`



<br /><hr /><br />



## 4-2. 아벨 군(Abelian Group)

`군(Group) 의 공리(Axiom)` 을 만족하면서, `교환 법칙 (Commutativity)` 를 만족한다면, `아벨 군(Abelian Group)` 으로 지칭합니다.



<br /><hr /><br />



## 4-3. 환(Ring) 의 공리(Axiom)

`아벨 군(Abelian Group)` 을 만족하면서, 아래의 법칙이 성립한다면, `환(Ring) 의 공리(Axiom)` 이라고 합니다.

1. `곱셈` 연산에 대해 `닫혀` 있습니다. (`Closure`)
2. `곱셈` 연산은 `결합 법칙 (Associativity)` 를 만족합니다.
3. `덧셈` 과 `곱셈` 연산에 대해 `분배 법칙 (Distributivity)` 를 만족합니다.

<br />

`환(Ring) 의 공리(Axiom)` 을 만족하는 경우, `기호` 로 다음과 같이 표현합니다.

* `(R, ＋, ·)`



<br /><hr /><br />



## 4-4. 가환환(Commutativity Ring)

`환(Ring) 의 공리` 를 만족하면서, 아래의 법칙이 성립한다면, `가환환(Commutativity)` 이라고 합니다.

1. `곱셈` 연산은 `교환 법칙 (Commutativity)` 를 만족합니다.
2. `곱셈` 연산의 `항등원 (Identity)` 이 존재합니다.



<br /><hr /><br />



## 4-5. 체(Field) 의 공리(Axiom)

`가환환 (Commutativity)` 를 만족하면서, 아래의 법칙이 성립한다면, `체(Field) 의 공리(Axiom)` 이라고 합니다.

1. `0` 을 제외한 모든 원소에 대해서, `곱셈` 의 `역원 (Inverse)` 가 존재 합니다.


<br />

`실수 (R)` 는 `체(Field) 의 공리(Axiom)` 를 가집니다.

`체(Field) 의 집합(Group)` 또는 `체(Field) 의 공리(Axiom)` 은 `기호` 로 `F` 로 표현하며, 여기에 속한 `원소 (element)` 를 `스칼라 (Scalar)` 라고 합니다.

* 게임 분야가 아닌, 일반적인 수학에서는 `실수 (R)` 뿐만 아니라, `유리수 (Q)` 와 `복소수 (C)` 도 `체(Field) 의 공리(Axiom)` 에 속하는 `수집합` 입니다.



<br /><hr /><br />



## 4-6. 수의 체계를 확장하여 이해하기

아래의 수식은 `사칙 연산` 을 표현 합니다.

* `a` + `b`

<br />

각 `요소` 를 단순한 `실수 (R)` 의 `덧셈` 으로만 본다면, 이는 `사칙연산` 의 범주에 머물게 됩니다.

지금까지 살펴보았던 `체(Field) 의 공리(Axiom)` 은 `실수 (R)` 도 만족하므로, `사칙 연산` 이 아닌 `체(Field) 의 공리(Axiom)` 범주로 볼 수 있으며, 다음과 같이 이해할 수 있습니다.

* `a` + `b`
* `스칼라 a` + `스칼라 b`
